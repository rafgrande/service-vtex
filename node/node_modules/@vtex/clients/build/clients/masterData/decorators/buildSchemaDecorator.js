"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildSchemaDecorator = void 0;
const api_1 = require("@vtex/api");
const services_1 = require("../services");
function buildSchemaDecorator(target) {
    var _a;
    for (const propertyName of Object.keys(Object.getOwnPropertyDescriptors(target.prototype))) {
        const classPropertyOrMethod = (_a = Object.getOwnPropertyDescriptor(target.prototype, propertyName)) !== null && _a !== void 0 ? _a : {};
        const isMethod = (classPropertyOrMethod === null || classPropertyOrMethod === void 0 ? void 0 : classPropertyOrMethod.value) instanceof Function;
        if (!isMethod) {
            continue;
        }
        if (propertyName === 'constructor') {
            continue;
        }
        const classMethod = classPropertyOrMethod;
        const originalMethod = classPropertyOrMethod === null || classPropertyOrMethod === void 0 ? void 0 : classPropertyOrMethod.value;
        const isMethodPromise = 'AsyncFunction' ===
            Object.getPrototypeOf(originalMethod).constructor.name.toString();
        if (isMethodPromise) {
            classMethod.value = async function (...args) {
                const entityConfiguration = services_1.CreateEntityConfigurationService.getInstance();
                const context = Object.getOwnPropertyDescriptor(this, 'context');
                const schema = await entityConfiguration.getSchema(api_1.MasterData, context === null || context === void 0 ? void 0 : context.value);
                Object.defineProperty(this, 'schema', {
                    value: schema,
                    writable: true,
                    enumerable: true,
                    configurable: true,
                });
                const result = await originalMethod.apply(this, args);
                return result;
            };
            Object.defineProperty(target.prototype, propertyName, classMethod);
        }
    }
}
exports.buildSchemaDecorator = buildSchemaDecorator;
